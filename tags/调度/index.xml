<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>调度 on 中间件</title>
    <link>https://www6v.github.io/www6vMiddleware/tags/%E8%B0%83%E5%BA%A6/</link>
    <description>Recent content in 调度 on 中间件</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Thu, 05 Jan 2017 23:38:39 +0000</lastBuildDate>
    <atom:link href="https://www6v.github.io/www6vMiddleware/tags/%E8%B0%83%E5%BA%A6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>延迟消息 时间轮</title>
      <link>https://www6v.github.io/www6vMiddleware/docs/%E5%85%B6%E4%BB%96/timedTask/</link>
      <pubDate>Thu, 05 Jan 2017 23:38:39 +0000</pubDate>
      <guid>https://www6v.github.io/www6vMiddleware/docs/%E5%85%B6%E4%BB%96/timedTask/</guid>
      <description>&#xA;关键词：延迟消息, 时间轮, Time Wheel&#xA;时钟轮的应用&#xD;#&#xD;Kafka中的应用 [1]&#xD;#&#xD;存在大量的延迟操作，比如延迟生产、延迟拉取以及延迟删除等&#xA;RPC中的应用 [6]&#xD;#&#xD;每次创建一个 Future，我们都记录这个 Future 的创建时间与这个 Future 的超时时间，并且有一个定时任务进行检测，当这个 Future 到达超时时间并且没有被处理时，我们就对这个 Future 执行超时逻辑。 每发一次请求，都创建一个处理请求超时的定时任务放到时钟轮里。 调用端与服务端启动超时也可以应用到时钟轮。&#xA;可以在调用端启动时创建一个处理启动超时的定时任务，放到时钟轮里。 RPC 框架调用端定时向服务端发送心跳，来维护连接状态，我们可以将心跳的逻辑封装为一个心跳任务，放到时钟轮里。 在定时任务的执行逻辑的最后，我们可以重设这个任务的执行时间，把它重新丢回到时钟轮里。 参考&#xD;#&#xD;Kafka解惑之时间轮（TimingWheel） 朱忠华 10w定时任务，如何高效触发超时 58沈剑 如何在MQ中实现支持任意延迟的消息？ 延迟任务的实现总结 nick hao rocketMq-延迟消息介绍 晴天哥_王志 * 《20 | 详解时钟轮在RPC中的应用》 何小锋 时间轮原理及其在框架中的应用 未 Dubbo 心跳检测 </description>
    </item>
  </channel>
</rss>
